# CPU_L2_CACHE_MISS_PROBLEM
Исследования и кое какие наработки по теме, промахов кэша обусловленных использованием указателей, а так же полиморфизма реализованного на таблицах виртуальных функций все тех же указателей.

Указатели зло, они фрагментируют память и приводят к значительным тормозам процессора, ведь операция подготовки кэша L2 стоит много времени, а сам L2 дорого обходится производителям процессоров.<br>
# И вообще зачем эти указатели нужны? 
* Ведь код при компиляции и компоновке наверняка очень хорошо оптимизируется и даже зловещее копирование памяти обусловленное использованием переменных созданных на стеке посильно этой оптимизации.
Как мы знаем размер стека ограничен и его переполнение грозит проблемами(можно перезаписать адресс функции возврата и перехватить управление программы), так получается невозможно создавать большие объекты в памяти, ну да его можно увеличить, но все же.
* Тогда было бы логично отдать под ответственность указателей ресурсы: картинки, медиа, документы, а все объекты создавать на стеке, и четко следить за их объемом, но черт бы побрал стек один функций много и размер его всего лишь 1МБ.<br><br>
# Хм а если задавать размером стека объем памяти который может использовать программа ?
Скажем указали при компиляции размер стека и пишем программу, только пошло переполнение, значит нужна оптимизация алгоритмов - интересная идея нужно будет как нибудь попрактиковать.<br><br>

Ну ладно массив, ну допустим списки односвязный и двусвязный мы можем обойтись без указателей, но почему тогда их придумали ? 
# Зачем ? 
Ответ - дерево и графы, не построить без указателей.<br><br>

# Назовем это NdFramework! N-Dimensions Framework
Вот я задался этим вопросом и написал интересную структуру называется bbs (base base structure) которая улаживает все "указывающие" структуры данных в массив.<br><br>

# Что мы имеем  ?
Мы имеем числовые поля-ключи, прямо как в базе данных, потом при добавлении в массив сортируем массив выстраивая их сродни обходу по дереву, меняя функтор сортировки мы можем изменять принцип обхода.<br><br>
<code>
bbs - base_base_structure
bbc - base_base_class
</code>

# План состоит из 3 этапов.
* Переписать оператор new() который выделяет память, сделать из его своеобразный менеджер памяти, при старте программы выделяется заявленный объем, и операторы new(), delete() управляют что бы память улаживалась в этот объем. - Так мы победим хотя бы на сколько нибудь фрагментацию памяти, в контексте new/delete вроде и нет никакого криминала в них.
* Внедрение Nd структур в промышленное программирование, оформление и публикация репозитория.
* Внесение изменений в компиляторы для улучшейной оптимизации описаных выше проблем.

# Проблема
* Важно помнить что возрастающий информационный поток ляжет на плечи простых граждан и не просто ляжет, а станет !еще! более неподъемным грузом, отсюда и будут псих. растройства и разного рода тяжести жизни.
   
